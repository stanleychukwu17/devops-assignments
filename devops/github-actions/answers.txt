1. {
    1. on: push                                 {push request events:}

    2. on: pull_request                         {pull request events:}

    3. on: issues:      {issues events:}
                types: [opened, edited]

    4. on: workflow_dispatch:                   {Workflow Dispatch:}
                inputs:
                    example_input:
                        description: 'An example input'
                        required: true
                        default: 'default_value'

    5. on: deployment_status:
                types: [success, failure]

    6. on: repository_dispatch:                 {Custom Events:}
                types: [my_custom_event]

    7. on: release:                             {Release Event:}
                types: [created, published]

    8. on: schedule:                            {Schedule Events:}
                - cron: '0 0 * * *' # Runs daily at midnight

    9. on: dependabot:                          {Dependabot Events:}
                types: [pull_request]

    10. on: workflow_run:                       {Workflow Run Events:}
                workflows: ["Main Workflow"]
                types:
                    - completed

    11. on: create:                             {fork events:}
                tags: [fork]
}

2.
    1. what are they?
        Github workflows are workflows that run in response to certain events/actions within our code
        repository @ github, each workflow should have at-least 1-job and each job can have multiple steps,
        but should have at-least 1 step. and a step can either be a shell-command or an action from the
        github-actions community. Each job is associated with a runner, The runner is a basically a machine
        or a compute engine that can be connected to github . The runner will establish a session and each
        steps in a job will be processed by this runner. The runner works on the steps from top to bottom.
        Steps cannot run in parallel, but jobs can run in parallel(i.e concurrently)
    
    2.  - inside your code repo, create a folder called ".github"
        - inside the .github folder, create a folder called: "workflows"
        - inside the workflows folder, here you can create all your github-actions workflows .yaml files

    3. see ./tasks/2-hello-world.yml

    4. the action is used to checkout/switch to the branch from where the event that triggered the
        workflow was called from, so if the push_request or pull_request was called from the
        "bug/fix-add-to-cart", the this action will switch to the branch "bug/fix-add-to-cart" and
        run your workflow in this specific branch
    
    5.
        - On your github actions page, at the top of the terminal where your workflow ran, you'll see
            a button [●●●] at the right corner, click on this button and you'll see a drop-down, this
            drop-down contains the following actions:
                view workflow file
                view workflow runs
                create status badge
                delete all logs
        - click on the settings button for the following options:
            show timestamps
            switch terminal to full-screen
            download logs
            view raw logs
        - click on the [search input] to search for something in your log, let's say in your workflow,
            somewhere you did: echo "stanley will be one of the greatest", you can use the [search input]
            to verify that this output is available in your log, and then you can also search for other
            expected outputs from your workflow
        - click on your [Re-run job button] to re-run all your jobs, this button is here because we
            added "workflow_dispatch" to our workflow, otherwise, if it was not present, you'd not
            see this button

3.
    see ./task/3-comment-on-issues.yml
    -
    we need to pass environment variables in the second job, the first job can access the environment
    variables internally because it is an action, but since we ae sending a post request, we also need
    to attach the environment variables

4.
    1. Read: Some of the principles of Continuous Integration
        1. Automate the build
        2. Introduce Automated test(unit testing, Integration testing)
        3. Linting (maybe)
        4. Security and Scanning (maybe)
    
    2. work on the workflow for a nodejs project, let it include testing

    3. work on the workflow for a golang project, let it include testing and test coverage report

    4. how do you set rules in your repo so that push_request & pull_request will only
        pass when certain jobs are successful {You can go to your github account and demonstrate it}