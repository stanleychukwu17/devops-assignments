1. it is a hook from framer-motion that is mostly used to track the changes to motion values and also
    to update motion elements with out triggering the react re-render engine
    e.g:
    const x = useMotionValue(0)
    const y = useMotionValue(0)
    <motion.div style={{x,y}} />

    - some of the methods for useMotionValue are
    .get()  .set()  .stop() .velocity() .destroy()

2.  const x = useMotionValue(0)
    const opacity = useTransform(x, [-200, 0, 200], [0,1,0])
    -
    return <motion.div drag="x" style={{x, opacity}} />

3.  const xInput = [-100, 0, 100]
    const opacityOutput = [0,1,0]
    const colorOutput = ['#f00', '#fff', '#0f0']

    const opacity = useTransform(x, xInput, opacityOutput)
    const color = useTransform(x, xInput, colorOutput)

4. useMotionTemplate creates a new motion value from a string template containing other motion values
    e.g-1:
    const x = useMotionValue(0)
    const transform = useMotionTemplate`transform(${x}px)`
    -
    return <motion.div style={{transform}} />

    e.g-2:
    const shadowX = useSpring(0)
    const shadowY = useMotionValue(0)

    const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`

    return <motion.div style={{filter: shadow}} />

5. useScroll is used to track the scroll progress of the web page or to track the scroll progress
    in an element
    e.g:
    const {scrollX, scrollY, scrollXProgress, scrollYProgress} = useScroll()
    -
    scrollX & scrollY: are the absolute scroll position in pixels
    scroll[X/Y]Progress: are the scroll position between a defined value between(0 to 1)i.e(0-100%)

    e.g-2: We could show a page scroll indicator by passing scrollYProgress straight to the scaleX
        style of a progress bar
    -
    const {scrollYProgress} = useScroll()
    const scaleX = useSpring(scrollYProgress)
    -
    return <motion.div style={{scaleX}} />

6.
    const ref = useRef<HTMLElement>({} as HTMLElement)
    const {scrollXProgress} = useScroll({container: ref})

    <svg>
        <motion.circle
            cx={50}, cy={30} r={30} fill="purple" style={{pathLength: scrollXProgress}}
        />
    </svg>
    <ul ref={ref}>
        <li>...</li>
        <li>...</li>
        <li>...</li>
    </ul>

7.
    const ref = useRef<HTMLElement>({} as HTMLElement)
    const {scrollXProgress} = useScroll({
        target: ref,
        offset: [0.2, 0.5]
    })

    return <motion.div ref={ref}>...</motion.div>

    offset explanation {
        - the offset property specifies the range of the scroll progress that you're interested in
            Accepted values are: number, text("start"|"center"|"end"), pixels,
                                percentage(0% to 100%), viewport(vh and vw)
        offset: [0.2, 0.5]:
            0.2: This represents the start of the range, meaning you want to begin tracking the scroll
                progress when the scroll position is at 20% of the target element's height
            0.5: This represents the end of the range, meaning you want to stop tracking when the scroll
                position reaches 50% of the target element's height.

        offset: ["100px", "400px"]:
            you're specifying a range based on pixel values rather than percentages
            -
            "100px": The tracking of scroll progress will begin when the scroll position is at 100 pixels
                from the top of the target element
            "400px": This indicates the endpoint of the scroll range. The tracking will stop when the scroll
                position reaches 400 pixels from the top of the target element
    }

8. useSpring creates a motion value that will animate to its latest target with a spring animation.
    e.g
        const x = useMotionValue(0)
        const spring = useSpring(x, {stiffness: 1000, damping: 10})
        ...
        return <motion.div style={{x:spring}}>...</motion.div>
    
    - options that can be passed into the useSpring hook are: {
        stiffness: the higher the number, the stiffer the object/element
        damping: it is the oscillation force, the lower the number the higher the oscillation, the
                higher the number, the lower the oscillation
        mass: it is the weight of the element, the higher the mass the slower the spring effect in
            terms of the element movement, the lower the mass the faster the movement
        bounce: the lower the number, the higher the bouncing of the element
    }

9. The useTransform hook creates a new motion value that transforms the output of one or more motion values
    e.g:
    const opacity = useTransform(x, [-100, 0, 100], [0,1,0])
    const color = useTransform(x, [-100, 0, 100], ['#f00', '#fff', '#0f0'])
    const rotate = useTransform(scrollY, [0, 100], [0,360], {clamp:false, ease:"ask chatGPT 4 values"})
    // by setting clamp to false, the increment will continue to map even when the max input value
        has been reached. e.g if scrollY is 200, rotate = 720
    
    -- using functions to transform output values
    e.g:1
    const x = useMotionValue(0)
    const y = useSpring(0)
    const z = useTransform([x,y], (latestX, latestY) => latestX * latestY)
    return <motion.div style={{x,y,z}} />
    -
    e.g:2
    const x = useMotionValue(0)
    const y = useTransform(x, latestX => Math.cos(value/10) * 50)
    return <motion.div style={{x,y}} />

10. Creates a motion value that tracks the velocity of another motion value. it accepts a motion value
    and returns a new one that updates with the provided motion values velocity
    e.g:
    const pink = (saturation: number) => {
        return `hsl(327, ${saturation}%, 50%)`
    }
    const HomeComp = () => {
        const x = useMotionValue(0)
        const smooth = useSpring(x, {damping:50, stiffness:400})
            // with this stiffness and damping above, the element will be very heavy
        const velocity = useVelocity(smooth)
        const scale = useTransform(velocity, [-3000,0,3000], [2,1,2], {clamp:false})
        const backgroundColor = useTransform(
            velocity,
            [-3000,0,3000],
            [pink(100), pink(0), pink(100)]
        )

        return (
            <motion.div
                drag="x"
                dragElastic={1}
                dragConstraints={{left:-200, right:200}}
                style={{x, scale, backgroundColor}}
        )
    }

11. useAnimationControls can create animation controls that can be used to start/stop animations on one or
    more motion components or multiple animations together
    e.g
    function HomeComp () {
        const controls = useAnimationControls()

        useEffect(() => {
            controls.start({x:"100px", scale:2, transition:{duration:3}})
        }, [])

        const takeItBack = useCallback(() => {
            controls.start({x:0, scale: 1})
        }, [])

        return <motion.div animate={controls} onClick={takeItBack} />
    }

11.1    controls.start("hidden")
        controls.start("visible")
        controls.start("hover")

11.2
    const sequence = async () => {
        await menuControl.start({x:0})
        return await itemsControl.start({opacity:1})
    }
    sequence().then(() => {
        childrenControls.start({y:-50, color:'#fefefe'})
    })

11.3
    useEffect(() => {
        controls.start(i => ({
            opacity:0, x:100,
            transition: {delay: i*0.3}
        }))
    })
    return (
        <ul>
            <motion.li custom={0} animate={controls}>...</motion.li>
            <motion.li custom={1} animate={controls}>...</motion.li>
        </ul>
    )

11.4
    .set(definition): the .set() method does not perform any animations, it is just like the gsap.set(),
        it just sets the attr/properties of the element to the value received
        --
        with properties: controls.set({opacity: 0})
        with variants: controls.set("hidden")
    .start():
        controls.start("hover", {duration: .5, ease:"easeIn"}) // i.e (definition, transitionOverride)
        controls.start({x:0, transition: {duration: 1}})
    .stop(): stops the animation at the current timeline


12. useAnimationFrame: is an animation loop that provides the latest frame time to the provided
    callback function, it runs a callback once every animation frame 
    e.g
    useAnimationFrame((time, delta) => {
        ref.current.style.transform = `rotateY(${time}deg)`
    })

13. The useInView hook is a simple hook to let you know when an element is within the viewport
    const ref = useRef(null)
    const isInView = useInView(ref)

    useEffect(() => {
        console.log("Element is in view", isInView)
    }, [isInView])

    return <motion.div ref={ref} />
    --
    - What are the options that can be provided to the hook?
    1. root: RefObject<HTMLElement>
        By default, the element will be tracked as it enters & leaves the window's viewport,
        Set root to be the ref of a scrollable parent & it will use that parent to be the viewport instead
        e.g:
            const ref = useRef(null)
            const container = useRef(null)
            const isInView = useInView(ref, {root: container})
            return (
                <motion.div ref={container} style={{overflow: "scroll"}}>
                    <div ref={ref} />
                </motion.div>
            )
    2. once: boolean
        if you set to true, the useInView hook will stop observing the element and always return true.
        The default is false
    3. amount: "some"|"all"|number
        The amount of the item that needs to enter the viewport for useInView to return true.
        You can also use number from 0-1, The default is 0

14. e.g:
    <motion.circle
        cx={300} cy={400}
        animate={{
            cx: [300,600],
            cy: [400,0,400],
            transition: {
                cx: {times: [0,1], duration: 1},
                cy: {times: [0, 0.5, 1], duration: 1},
            }
        }}
    />

    e.g:2
    variant = {
        x: [null, 100, 0] // here if the value is animating, null will continue from the current value
    }

15. whileHover, whileTap, whileFocus, whileDrag, whileInView


