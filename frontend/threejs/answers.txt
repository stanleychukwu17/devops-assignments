1 - Read: introduction
      React-three-fibre is a react renderer for three.js. it helps you build your scene declaratively with
      re-useable, self-contained components that react to state, are readily interactive and can participate
      in React's ecosystem

    *Warning:
      React-three-fibre is a react renderer, it must pair with a major version of react, just like react-dom,
      react-native e.t.c @react-three/fiber@8 pairs with react@18, @react-fiber@9 pairs with react@19

    *Does it have limitations?:
      None, everything that works in three.js will work here without exceptions

    *Is it slower than plain three.js:
      No, there is no overhead, components render outside of React, it outperforms plain three.js in scale due
      to react's scheduling abilities

    *Can it keep up with frequent feature updates to three.js:
      Yes. it merely expresses three.js in JSX, <mesh /> dynamically turns into a new THREE.Mesh(). if a new
      three.js version adds, removes or changes features, it will be available to you instantly without
      depending on updates to this library

  - Read: installing react-three-fibre
    pnpm install three @types/three @react-three/fibre

  - Read: see some of the ecosystem of react-three-fibre
    There is a vibrant and extensive eco system around three-fiber full of libraries, helpers and abstractions
    -
    - @react-three/drei: useful helpers, this is an ecosystem in itself
    - @react-three/gltFjx: turns GLTFs into JSX components
    - @react-three/postProcessing: post processing effects
    - @react-three/test-renderer: for unit tests in node
    - @react-three/flex: flexBox for react-three-fiber
    - @react-three/xr: VR/AR controllers and events
    - @react-three/cannon: 3D physics using canon
    - create-r3f-app next: nextjs starter

2 Transforming objects
  - Name 3 ways to to transform an object
    1. position   2. scale    3. rotation

  - Read a little about object transformation
    -
    All the objects that inherits from "Object3D" possesses these transformation properties: (i.e scale,
    rotation, position). If ypu go to 3.js doc, you'll see the classes of each objects(i.e the classes
    they inherit from)
    e.g:
      for a mesh: Object3D -> Mesh
      for a group: Object3D -> group
      for a perspective camera: Object3D -> Camera -> Perspective Camera

    To adjust any of the 4 properties above, we can manipulate the x,y,z axis on each of the properties
    e.g:
      mesh.position.x = 2;
      mesh.position.y = 1.5;
      mesh.position.z = -0.2;
      mesh.position.set(x,y,z) e.g: mesh.position.set(2,1.5,-0.2)

    The position and scale property inherits from the "vector3" class, and this "vector3" class has
    many useful methods, some of them are:

    - mesh.position.length(): gives you the distance of an object from the center of the scene
    - position.distanceTo(camera.position): gives you the distance btw the camera and the mesh
    - position.normalize(): takes the length of your "vector3" object and reduces it until it is 1,
        there by bringing the object back to the center of the scene
    - position.set(x,y,z): set all 3 axis at once, you can also do mesh.scale.set(x,y,z)

  - where do all 3 axis face in 3.js, draw the axis
      in three.js:
      y
      |
      |
      |__ __ __ x
      z

      in blender front-view (1)
      z
      |
      |
      |__ __ __ x
      y

  - How do you make the camera look at an object
    "Object3D" instances have a .lookAt() method which rotates the object so that its z faces the target
    you provided. the target must be a vector3. this is mostly used for the camera
    e.g:
    camera.lookAt(new THREE.Vector3(0,0,0))
    camera.lookAt(mesh.position)

