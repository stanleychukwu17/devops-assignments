1. The terraform core workflow is
    Write:
    Plan:
    Apply

2.  terraform is nothing without providers, every terraform project, you need to specify a provider, there are providers
    for every major cloud infrastructure platform, these providers can be compared to your nodejs packages,
    in these providers are the code that will be used to provision your infrastructure

3.
    terraform {
        required_providers {
            aws = {
                source = "hashicorp/aws"
                version = "~>5.0"
            }
        }
    }

    provider "aws" {
        region = "eu-north-1"
        access_key = ""
        secret_key = ""
    }

4.
    resource "aws_vpc" "main" {
        cidr_block = "10.0.0.0/16"
        enable_dns_support = true
        enable_dns_hostname = true
    }

    resource = is a block.. i.e a "resource block"
    cidr_block, enable_dns_hostname, enable_dns_support = arguments
    aws_vpc, main = label names
    aws_vpc = resource type.. i.e "aws_vpc resource type"
    main = local_name {used for local identification}

5. terraform init - this will download all of the required_providers

6. VPC -> Subnet -> Route table & Internet Gateway -> Security groups -> EC2 instance {
    For EC2 instance, we need:
        data for "ami" automatic fetching
        keyGen for ssh logging into your EC2 vm
}

7. resource <provider_resourceName> <local_name> { ...arguments }

8. Classless Inter Domain Routing

9.
    resource "aws_vpc" "main" {
        cidr_block = var.vpc_cidr_block
        enable_dns_hostname = true
        enable_dns_support = true

        tags = {
            Name = "Dev Env ${var.main_vpc_name}"
        }
    }

10. - terraform plan
    - terraform apply
    - terraform plan -out=tfplan or terraform plan -out tfplan
    - terraform apply "tfplan" or terraform apply "tfplan" -auto-approve

11. - terraform apply -auto-approve
    - terraform fmt
    - terraform fmt <name_of_folder>
      terraform fmt -diff
      terraform fmt -recursive
    - terraform validate

12. - terraform destroy
    - terraform destroy -auto-approve
    - terraform destroy -target "aws_vpc.main"
    - terraform apply -replace="aws_vpc.main"

13. D:\Sz - projects\0-exercise\terraform\answers\13_a.tf

14. you use the variable block
    variable "vpc_cidr_block" {
        default = "10.0.0.0/16"
        description = "The cidr block for the main vpc for development stage"
        type = string
    }
    - you save variables in two file: variables.tf & terraform.tfvars

15. terraform apply -auto-approve -var="vpc_cidr_block=10.0.0.0/16" -var="subnet_cidr_block=10.0.10.0/24"

16. terraform.tfvars does not compile with the other terraform files(i.e .tf files) into a single module
    - terraform.tfvars stores only the values. no description, no type
    - variables.tf stores everything, the default, description, type arguments can all be passed into variables in the variable block

17. touch production.tfvars
    terraform apply -auto-approve -var-file=production.tfvars

18. here is how to use it in your main.tf:
    resource "aws_vpc" "main" {
        cidr_block = var.vpc_cidr_block

        tags = {
            Name = "${var.environment_stage} VPC"
        }
    }

    - resource "aws_subnet" "web_subnet" {
        cidr_block = var.subnet_cidr_block
        vpc_id = aws_vpc.main.id
        availability_zone = var.subnet_availability_zone_1

        tags = {
            Name = "${var.environment_stage} subnet for VPC"
        }
    }

19. this is how they are applied into your config files
    -var & -var-file
    terraform.tfvars
    environment variables "TF_VAR_*"

20. A route table is a virtual router within your vpc, A default route table contains routes that determine where the
    network traffic is directed. The default route table controls the routing for all subnets that belongs to the vpc
    and are not explicitly associated with other route table. So basically, the route table controls routing for all
    subnets within the vpc

    An Internet Gateway - is a managed service that allows communication between instances in a Virtual Private Cloud (VPC)
    and the internet

21. - An aws_security_group is an aws managed service that determines if internet traffic are permitted into or out of
      an instance
    - aws_security_group = You have to create this one by yourself using the resource "aws_security_group"
      aws_default_security_group = This one comes by default when you create the VPC, it is always better to leave
        this one alone and create new security groups

22. in variables.tf
    variable "general_public_address" {
        description = "everyone is allowed to visit this EC2 instance"
        type = string
    }
    in terraform.tfvars
    general_public_address = 0.0.0.0/0
    ----
    resource "aws_security_group" "ec2_security" {
        vpc_id = aws_vpc.main.id
    
        # for ssh connections
        ingress {
            from_port = 22
            to_port = 22
            protocol = "tcp"
            cidr_block = [var.general_public_address]
        }

        # for http connection
        ingress {
            from_port = 80
            to_port = 80
            protocol = "tcp"
            cidr_block = [var.general_public_address]
        }

        # for outgoing request
        egress {
            from_port = 0
            to_port = 0
            protocol = "-1" # any type of request
            cidr_block = ["0.0.0.0/0"]
        }
    
        tags = {
            Name = "EC2 security group"
        }
    }

    22.
        resource "aws_instance" "my_vm" {
            ami =                           "ami-4094940048585fse2"
            instance_type =                 "t2.micro"
            subnet_id =                     aws_subnet.web_subnet.id
            vpc_security_group_ids =        [aws_security_group.ec2_security.id]
            associate_public_ip_address =   true
            key =                           "production_ssh_key"

            tags = {
                Name = "My EC2 instance - Selling town EC2_1"
            }
        }