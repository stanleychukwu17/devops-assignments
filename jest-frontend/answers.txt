1.  App.tsx -> App.test.tsx
    itemDisplay.tsx -> itemDisplay.test.tsx

2.  getBy,      findBy,         queryBy
    getAllBy,   findAllBy       queryAllBy

3.  getByRole       getByLabelText      getByPlaceholderText        getByText
    getByAltText    getByTitle
    getByTestId     getAllByTestId

4. const headingElement = await screen.findByRole(/how far/i)

5.
    it("should not find any heading element", () => {
        render(<Header title="my header" />)
        const header = screen.queryByText(/dogs/i)

    })

6.  const headingElement = screen.getAllByRole("heading")
    expect(headingElement.length).toBe(3)
    expect(headingElement).toHaveLength(3)

7.
    describe("Testing the cart total", () => {
        it("should add 5 products to the cart", () => { ... })
        it("should show $55.58 as total", () => { ... })
    })

8.
    it("should have empty input when add button is clicked", async () => {
        render(<AddInput />)

        const inpElement = screen.getByPlaceholderText(/add your todo/i)
        const btnElement = screen.getByRole("button", {name: /add/i})

        fireEvent.change(inpElement, {target: {value: "Buy Soap"}})
        fireEvent.click(btnElement)

        expect(inpElement.value).toBe("")
    })

9.
    beforeEach: The beforeEach() function runs every-time before each of your test runs
    afterEach: The afterEach() function runs every-time after each of your test runs
    beforeAll: The beforeAll() function runs once before any of your test starts/runs
    afterAll: The afterAll() function runs once after all your test have finished running

    e.g
    describe("Testing followerList", () => {
        beforeAll(() => { render the main component })
        afterAll(() => { clearAllMock, delete any data created to the database })

        beforeEach(() => { ... })
        afterEach(() => { clearAllMock() })

        it(" ... ", () => { ... })
        it(" ... ", () => { ... })
        it(" ... ", () => { ... })
    })

10.
    it("should load 6 more products", async () => {
        render(<App />)

        const btn = screen.getByRole("button", {name: /load more/i})
        fireEvent.click(btn)

        waitFor(async () => {
            const headingElement = await screen.findAllByRole("heading")
            expect(headingElement).toHaveLength(12)
        })
    })

11. expect(['a','b']).toHaveLength(2)
    expect(5).toEqual(5)
    expect(['a','b','c']).toContain('b')
    expect(fn).toThrow()
    expect(mock).toHaveBeenCalled()

12. user.click(element)
    user.keyboard("stanley"); simulates typing "stanley"
    user.keyboard("{Enter}"); simulates pressing the enter key on the keyboard

13.
    it("should call onUserAdd when the form is submitted", () => {
        const argList = []
        const callBack = (...args) => {
            argList.push(args)
        }

        render(<UserForm onUserAdd={callBack} />)

        const [nameInput, emailInput] = scene.getAllByRole("textBox")
        user.click(nameInput)
        user.keyboard("jane")

        user.click(emailInput)
        user.keyboard("jane@jane.com")

        const btn = scene.getByRole("button")
        user.click(btn)

        // Assertion to make sure 'onUserAdd' gets called with email & name
        expect(argList).toHaveLength(1)
        expect(argList[0[0]]).toEqual({name: "jane", email: "jane@jane.com"})
    })

14.
    const mock = jest.fn()
    render(<UserForm onUserAdd={mock} />)

    expect(mock).toHaveBeenCalled()
    expect(mock).toHaveBeenCalledWith({name: "jane", email: "jane@jane.com"})

15.
    Below is the element
    <label htmlFor="email"> Enter email </label>
    <input id="email" data-testid="user_email" />

    scene.getByLabelText(/enter email/i)
    scene.getByRole("textBox", {name: /enter email/i})
    scene.getByTestId("user_email")

16. when you use this method. it gives you a url that when you click on takes you to a web page that shows
    you your rendered component, when you hover over each element you'll see how you can select the elements
    from jest

17. How do you use within
    const rows = within(scene.getByTestId("users")).getAllByRole("rows")

18. it is used to logout the current state of your dom when you're testing. this will show you what your
    html dom looks like at the point where you used the screen.debug()

19. An Accessible name is the text inside an element
    e.g
    <button>Submit now</button>
    <div>
        <button aria-label="sign-in"><svg /></button>
        <button aria-label="sign-out"><svg /><button>
    </div>
    Answer:
    const submitBtn = scene.getByRole("button", {name: /submit now/i})
    const signOut = scene.getByRole("button", {name: /sign-out/i})

20.
    - To prove an element(s) exist, use:
        getBy, getAllBy
    - To prove an element(s) does not exist, use:
        queryBy, queryAllBy
    - To prove and element(s) eventually exists, use:
        findBy, findAllBy

21. 