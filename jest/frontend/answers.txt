1.  App.tsx -> App.test.tsx
    itemDisplay.tsx -> itemDisplay.test.tsx

2.  getBy,      findBy,         queryBy
    getAllBy,   findAllBy       queryAllBy

3.  getByRole       getByLabelText      getByPlaceholderText        getByText
    getByAltText    getByTitle
    getByTestId     getAllByTestId

4. const headingElement = await screen.findByText(/how far/i)

5.
    it("should not find any heading element", () => {
        render(<Header title="my header" />)
        const header = screen.queryByText(/dogs/i)
    })

6.  const headingElement = screen.getAllByRole("heading")
    expect(headingElement.length).toBe(3)
    expect(headingElement).toHaveLength(3)

7.
    describe("Testing the cart total", () => {
        it("should add 5 products to the cart", () => { ... })
        it("should show $55.58 as total", () => { ... })
    })

8.
    it("should have empty input when add button is clicked", async () => {
        render(<AddInput />)

        const inpElement = screen.getByPlaceholderText(/add your todo/i)
        const btnElement = screen.getByRole("button", {name: /add/i})

        fireEvent.change(inpElement, {target: {value: "Buy Soap"}})
        fireEvent.click(btnElement)

        expect(inpElement.value).toBe("")
    })

9.
    beforeEach: The beforeEach() function runs every-time before each of your test runs
    afterEach: The afterEach() function runs every-time after each of your test runs
    beforeAll: The beforeAll() function runs once before any of your test starts/runs
    afterAll: The afterAll() function runs once after all your test have finished running

    e.g
    describe("Testing followerList", () => {
        beforeAll(() => { render the main component })
        afterAll(() => { clearAllMock, delete any data created to the database })

        beforeEach(() => { ... })
        afterEach(() => { clearAllMock() })

        it(" ... ", () => { ... })
        it(" ... ", () => { ... })
        it(" ... ", () => { ... })
    })

10.
    it("should load 6 more products", async () => {
        render(<App />)

        const btn = screen.getByRole("button", {name: /load more/i})
        fireEvent.click(btn)

        waitFor(async () => {
            const headingElement = await screen.findAllByRole("heading")
            expect(headingElement).toHaveLength(12)
        })
    })

11. expect(['a','b']).toHaveLength(2)
    expect(5).toEqual(5)
    expect(['a','b','c']).toContain('b')
    expect(fn).toThrow()
    expect(mock).toHaveBeenCalled()

12. userEvent.click(element)
    userEvent.type("stanley"); simulates typing "stanley"
    userEvent.keyboard("{enter}"); simulates pressing the enter key on the keyboard

13. {
    import { render, screen } from '@testing-library/react';
    import userEvent from '@testing-library/user-event';
    import MyForm from './MyForm';

    test('should submit form on Enter key press', async () => {
        render(<MyForm />);
        
        // Find the input field and submit button
        const input = screen.getByLabelText(/username/i);
        const submitBtn = screen.getByRole('button', { name: /submit/i });
        
        // Type into the input field
        await userEvent.type(input, 'test-user');
        
        // Simulate pressing the Enter key
        await userEvent.keyboard('{enter}');

        // Click on the submitBtn
        await userEvent.click(submitBtn)
        
        // Assert the expected behavior after the Enter key press
        expect(screen.getByText(/form submitted/i)).toBeInTheDocument();
    });
}

13.1 {
    Use userEvent when you want to simulate user interactions in a way that closely mirrors real user behavior.
        Itâ€™s especially useful for typing, multi-step interactions, and more complex scenarios.

    Use fireEvent for simpler cases where direct event dispatching is sufficient, or when you need to trigger
        events that are not covered by userEvent.
}

14.
    const mock = jest.fn()
    render(<UserForm onUserAdd={mock} />)

    expect(mock).toHaveBeenCalled()
    expect(mock).toHaveBeenCalledWith({name: "jane", email: "jane@jane.com"})

15.
    Below is the element
    <label htmlFor="email"> Enter email </label>
    <input id="email" data-testid="user_email" />

    scene.getByLabelText(/enter email/i)
    scene.getByRole("textBox", {name: /enter email/i})
    scene.getByTestId("user_email")

16. when you use this method. it gives you a url that when you click on takes you to a web page that shows
    you your rendered component, when you hover over each element you'll see how you can select the elements
    from jest

17. How do you use within
    const rows = within(scene.getByTestId("users")).getAllByRole("rows")

18. it is used to logout the current state of your dom when you're testing. this will show you what your
    html dom looks like at the point where you used the screen.debug()

19. An Accessible name is the text inside an element
    e.g
    <button>Submit now</button>
    <div>
        <button aria-label="sign-in"><svg /></button>
        <button aria-label="sign-out"><svg /><button>
    </div>
    Answer:
    const submitBtn = scene.getByRole("button", {name: /submit now/i})
    const signOut = scene.getByRole("button", {name: /sign-out/i})

20.
    - To prove an element(s) exist, use:
        getBy, getAllBy
    - To prove an element(s) does not exist, use:
        queryBy, queryAllBy
    - To prove and element(s) eventually exists, use:
        findBy, findAllBy

21. 
    Answer:
    function toContainRole(container, role, quantity = 1) {
        const elements = within(container).queryAllByRole(role)
        if(elements.length === quantity) {
            return {pass:true}
        }

        return {
            pass: false,
            message: () => `Expected to find ${quantity} ${role} elements`
        }
    }